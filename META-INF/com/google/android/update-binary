#!/sbin/sh

OUTFD=/proc/self/fd/$2
ZIPFILE="$(pwd)/$3"

tmp=/dev/tmp
rm -rf $tmp
mkdir -p $tmp
cd $tmp


ui_print() {
  echo -e "ui_print $1\nui_print" >>$OUTFD
}

rm -rf zhlhlf.log
log() {
    echo "$1" >> ./zhlhlf.log
}

abort() { 
    ui_print "$1"
    ui_print " "
    exit 1
}

exist() {
    if [ "$(unzip -l "$ZIPFILE" | grep $1)" ] || [ -f $1 ];then
      echo 1
    else        
      echo 0
    fi
}

keyListener() {
  key=$(getevent -qlc 1 2>&1 | grep VOLUME | grep " DOWN" | awk '{print $3}')
  if [ $key = "KEY_VOLUMEUP" ]; then
    echo "1"
    return "1"
  elif [ $key = "KEY_VOLUMEDOWN" ]; then
    echo "0"
    return "0"
  else 
    keyListener
  fi
}

#判断ddr类型
if [ "$(cat /proc/devinfo/ddr_type | grep -i DDR4)" ];then
    hh=ddr4
elif [ "$(cat /proc/devinfo/ddr_type | grep -i DDR5)" ];then
    hh=ddr5
elif [ "$(getprop ro.boot.ddr_type | grep -i 0)" ]; then
    hh=ddr4
elif [ "$(getprop ro.boot.ddr_type | grep -i 1)" ]; then
    hh=ddr5
else
    abort "ddr get fail"
fi


package_extract_file() {
 if [ `exist $1` = 0 ];then
    ui_print "$1 Not in the zip file"
    return
 fi
  ui_print "flash `basename $1` -> `basename $2`"
  if [ "$3" ];then
    dd if=$1 of=$2 bs=4K
    return
  fi
  unzip -p "$ZIPFILE" $1 >$2
}

package_extract_zstd() {
  ui_print "flash `basename $1` to `basename $2`"
  unzip -p "$ZIPFILE" $1 | $tmp/scripts/zstd -c -d >$2
}

ui_print " "
ui_print "you device type is: $hh"
ui_print "-----------------------------------------"
ui_print "             Author by zhlhlf"
ui_print "-----------------------------------------"


ui_print "update firmware....."
package_extract_file firmware-update/oppo_sec.img /dev/block/by-name/oppo_sec
package_extract_file firmware-update/BTFM.img /dev/block/by-name/bluetooth
package_extract_file firmware-update/DRIVER.img /dev/block/by-name/DRIVER
package_extract_file firmware-update/abl.img /dev/block/by-name/abl
package_extract_file firmware-update/aop.img /dev/block/by-name/aop
package_extract_file firmware-update/cdt_engineering.img /dev/block/by-name/engineering_cdt
package_extract_file firmware-update/cmnlib.img /dev/block/by-name/cmnlib
package_extract_file firmware-update/cmnlib64.img /dev/block/by-name/cmnlib64
package_extract_file firmware-update/devcfg.img /dev/block/by-name/devcfg
package_extract_file firmware-update/dpAP.img /dev/block/by-name/apdp
package_extract_file firmware-update/dspso.img /dev/block/by-name/dsp
package_extract_file firmware-update/hyp.img /dev/block/by-name/hyp
package_extract_file firmware-update/keymaster64.img /dev/block/by-name/keymaster
package_extract_file firmware-update/modem.img /dev/block/by-name/modem
package_extract_file firmware-update/qupv3fw.img /dev/block/by-name/qupfw
package_extract_file firmware-update/splash.img /dev/block/by-name/splash
package_extract_file firmware-update/static_nvbk.img /dev/block/by-name/mdm_oem_stanvbk
package_extract_file firmware-update/storsec.img /dev/block/by-name/storsec
package_extract_file firmware-update/recovery.img /dev/block/by-name/recovery

if [ $hh = "ddr4" ];then
    package_extract_file firmware-update/xbl_config_ddr4.img /dev/block/by-name/xbl_config
    package_extract_file firmware-update/xbl_ddr4.img /dev/block/by-name/xbl
    package_extract_file firmware-update/imagefv_ddr4.img /dev/block/by-name/imagefv
elif [ $hh = "ddr5" ];then
    package_extract_file firmware-update/xbl_config_ddr5.img /dev/block/by-name/xbl_config
    package_extract_file firmware-update/xbl_ddr5.img /dev/block/by-name/xbl
    package_extract_file firmware-update/imagefv_ddr5.img /dev/block/by-name/imagefv
fi



ui_print " "
#开始生成和刷入super并刷入images剩余部分
if [ `exist "images/super.zst"` = 1 ];then
    unzip -o "$ZIPFILE" scripts/*
    chmod 777 * -R
    package_extract_zstd "images/super.zst" "/dev/block/bootdevice/by-name/super"
    list="boot dtbo vbmeta vbmeta_system vbmeta_vendor"
    for i in $list
    do
        package_extract_file images/${i}.img /dev/block/by-name/${i}
    done
elif [ `exist "images/system.img"` = 1 ];then

    check_datasize(){
      #判断data是否挂载成功能否有足够大小存放解包出来的images
      datasize=$(df -h /data | grep /dev/block | awk '{print $4}')
      if [ `echo $datasize | sed s/[[:digit:]]//g` = "G" ] && [ `echo $datasize | sed s/G//g` -gt 20 ];then
      return
      else
          log "data分区大小错误，需要自行格式化data分区"
          abort "data mount fail"
      fi
    }
    
    check_datasize 

    tmp=/data/tmp
    rm -rf $tmp
    mkdir -p $tmp
    cd $tmp

    list="boot dtbo vbmeta vbmeta_system"

    if [ `exist images/my_stock.img` = 1 ];then
        list_super="odm.img product.img vendor.img system.img system_ext.img my_company.img my_preload.img my_engineering.img my_product.img my_heytap.img my_region.img my_carrier.img my_manifest.img my_stock.img"
    else
        list_super="odm.img product.img vendor.img system.img system_ext.img"
    fi

    if [ `exist images/my_bigball.img` = 1 ];then
        list_super+=" my_bigball.img"
    fi

    images_all = 1

    images_exist(){
        for i in `echo $1 | cut -d' ' -f1-*`
        do
            i=$(basename $i .img)
            if [ `exist images/$i.img` != 1 ];then
                images_all=0
                return
            fi
        done
    }
    #验证是否存在需要的镜像
    images_exist "$list"
    images_exist "$list_super"

    if [ $images_all = 0 ];then
        abort "images bad"
    fi

    ui_print "extarct images/* ..."

    unzip -o "$ZIPFILE" images/*
    unzip -o "$ZIPFILE" scripts/*
    export PATH=$(pwd)/scripts:$PATH
    chmod 777 * -R        
    mv images project

    flash_images(){
        . ./scripts/functions.sh
        make_super "9126805504" "project" "$list_super" "A"
        if [ -f project/super.img ];then
            package_extract_file project/super.img /dev/block/by-name/super "1"
        else
            abort "make super fail"
        fi

        for i in $list
        do
            package_extract_file project/${i}.img /dev/block/by-name/${i} "1"
        done
    }

    #开始生成和刷入super并刷入images剩余部分
    flash_images
fi
rm -rf $tmp
